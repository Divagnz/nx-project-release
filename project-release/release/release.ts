import { PromiseExecutor, logger, ExecutorContext, runExecutor as nxRunExecutor } from '@nx/devkit';
import { execSync } from 'child_process';
import * as path from 'path';
import * as fs from 'fs';
import * as semver from 'semver';
import { ReleaseExecutorSchema } from './schema';

const runExecutor: PromiseExecutor<ReleaseExecutorSchema> = async (options, context: ExecutorContext) => {
  logger.info('Running project-release executor');

  try {
    // Check if we should only process affected projects
    if (options.onlyChanged) {
      const isAffected = await isProjectAffected(context, options);
      if (!isAffected) {
        logger.info(`‚è≠Ô∏è Project ${context.projectName} is not affected, skipping release`);
        return { success: true, skipped: true };
      }
    }

    // Check if project should be skipped based on configuration
    if (await shouldSkipProject(context.projectName!, options)) {
      logger.info(`‚è≠Ô∏è Project ${context.projectName} is configured to be skipped`);
      return { success: true, skipped: true };
    }

    // Simple project configuration - read from workspace
    const projectRoot = context.projectsConfigurations?.projects[context.projectName!]?.root || context.projectName!;
    logger.info(`Project root: ${projectRoot}`);

    // Read current version from specified file
    const versionInfo = await readVersionFromFile(context, projectRoot, options);
    let currentVersion = versionInfo.version || '0.0.0';
    logger.info(`Current version: ${currentVersion} (from ${versionInfo.filePath})`);

    // Calculate new version
    let newVersion: string;
    if (options.version) {
      // Validate semver format
      if (!semver.valid(options.version)) {
        throw new Error(`Invalid semver version: ${options.version}`);
      }
      newVersion = options.version;
    } else if (options.releaseAs) {
      newVersion = semver.inc(currentVersion, options.releaseAs) || currentVersion;
    } else {
      // Default to patch bump if no conventional commits analysis
      logger.info('No version specified, defaulting to patch bump');
      newVersion = semver.inc(currentVersion, 'patch') || currentVersion;
    }

    logger.info(`New version: ${newVersion}`);

    if (options.dryRun) {
      logger.info('DRY RUN - No changes will be made');
      logger.info(`Would update version from ${currentVersion} to ${newVersion}`);
      if (!options.skipTag) {
        const tag = options.tag || generateTagName(context.projectName!, newVersion, options);
        logger.info(`Would create git tag: ${tag}`);
      }
      return { success: true };
    }

    // Update version file with new version
    await writeVersionToFile(context, projectRoot, options, newVersion, versionInfo.filePath);

    // Create git commit if not skipped
    if (!options.skipCommit) {
      const commitMessage = generateConventionalCommitMessage(context.projectName!, newVersion);
      execSync(`git add ${versionInfo.filePath}`, { cwd: context.root });
      execSync(`git commit -m "${commitMessage}"`, { cwd: context.root });
      logger.info(`Created conventional commit for release ${newVersion}`);
    }

    // Create git tag if not skipped
    if (!options.skipTag) {
      const tag = options.tag || generateTagName(context.projectName!, newVersion, options);
      execSync(`git tag ${tag}`, { cwd: context.root });
      logger.info(`Created git tag: ${tag}`);
    }

    // Publish package if requested
    if (options.publish && !options.dryRun) {
      logger.info('üì¶ Publishing package...');
      await publishPackage(options, context, projectRoot, newVersion);
    } else if (options.publish && options.dryRun) {
      logger.info('DRY RUN - Would publish package to registry');
    }

    logger.info(`‚úÖ Successfully released ${context.projectName} version ${newVersion}`);
    return { success: true };

  } catch (error: any) {
    logger.error(`‚ùå Release failed: ${error.message}`);
    return { success: false, error: error.message };
  }
};

function generateConventionalCommitMessage(projectName: string, version: string): string {
  return `chore(release): ${projectName} v${version}

Generated by project-release executor following conventional commits specification.`;
}

async function publishPackage(
  options: ReleaseExecutorSchema,
  context: ExecutorContext,
  projectRoot: string,
  version: string
): Promise<void> {
  const registryType = options.registryType || 'npm';
  const registry = options.registry;
  const distTag = options.distTag || 'latest';
  const access = options.access || 'public';
  const publishDir = options.publishDir || `dist/${context.projectName}`;

  // Run build target if specified
  if (options.buildTarget) {
    logger.info(`üî® Building project with target: ${options.buildTarget}`);

    try {
      await nxRunExecutor(
        { project: context.projectName!, target: options.buildTarget },
        {},
        context
      );
      logger.info('‚úÖ Build completed successfully');
    } catch (error: any) {
      throw new Error(`Build failed: ${error.message}`);
    }
  }

  // Ensure publish directory exists
  const fullPublishDir = path.join(context.root, publishDir);
  if (!fs.existsSync(fullPublishDir)) {
    throw new Error(`Publish directory does not exist: ${fullPublishDir}`);
  }

  // Update package.json in publish directory
  const publishPackageJsonPath = path.join(fullPublishDir, 'package.json');
  if (fs.existsSync(publishPackageJsonPath)) {
    const publishPackageJson = JSON.parse(fs.readFileSync(publishPackageJsonPath, 'utf8'));
    publishPackageJson.version = version;
    fs.writeFileSync(publishPackageJsonPath, JSON.stringify(publishPackageJson, null, 2));
    logger.info(`Updated ${publishPackageJsonPath} with version ${version}`);
  }

  // Publish based on registry type
  switch (registryType) {
    case 'npm':
      await publishToNpm(fullPublishDir, registry, distTag, access);
      break;
    case 'nexus':
      await publishToNexus(fullPublishDir, registry, context.projectName!);
      break;
    case 'custom':
      await publishToCustomRegistry(fullPublishDir, registry, distTag, access);
      break;
    default:
      throw new Error(`Unsupported registry type: ${registryType}`);
  }

  logger.info(`‚úÖ Successfully published ${context.projectName} v${version} to ${registryType} registry`);
}

async function publishToNpm(publishDir: string, registry?: string, distTag = 'latest', access = 'public'): Promise<void> {
  const publishCmd = ['npm', 'publish'];

  if (registry) {
    publishCmd.push('--registry', registry);
  }

  publishCmd.push('--tag', distTag);
  publishCmd.push('--access', access);

  logger.info(`Publishing to npm: ${publishCmd.join(' ')}`);
  execSync(publishCmd.join(' '), { cwd: publishDir, stdio: 'inherit' });
}

async function publishToNexus(publishDir: string, registry: string, projectName: string): Promise<void> {
  if (!registry) {
    throw new Error('Registry URL is required for Nexus publishing');
  }

  // For Nexus, we typically use npm publish with the registry URL
  const publishCmd = ['npm', 'publish', '--registry', registry];

  logger.info(`Publishing to Nexus: ${publishCmd.join(' ')}`);
  execSync(publishCmd.join(' '), { cwd: publishDir, stdio: 'inherit' });
}

async function publishToCustomRegistry(publishDir: string, registry?: string, distTag = 'latest', access = 'public'): Promise<void> {
  if (!registry) {
    throw new Error('Registry URL is required for custom registry publishing');
  }

  const publishCmd = ['npm', 'publish', '--registry', registry, '--tag', distTag, '--access', access];

  logger.info(`Publishing to custom registry: ${publishCmd.join(' ')}`);
  execSync(publishCmd.join(' '), { cwd: publishDir, stdio: 'inherit' });
}

async function isProjectAffected(context: ExecutorContext, options: ReleaseExecutorSchema): Promise<boolean> {
  try {
    const affectedCmd = ['npx', 'nx', 'show', 'projects', '--affected'];

    if (options.baseBranch) {
      affectedCmd.push('--base', options.baseBranch);
    }

    if (options.sinceSha) {
      affectedCmd.push('--head', options.sinceSha);
    }

    const result = execSync(affectedCmd.join(' '), {
      cwd: context.root,
      encoding: 'utf8',
      stdio: 'pipe'
    });

    const affectedProjects = result.trim().split('\n').filter(p => p.trim());
    return affectedProjects.includes(context.projectName!);
  } catch (error: any) {
    logger.warn(`Could not determine affected projects: ${error.message}`);
    return true; // Default to including project if we can't determine
  }
}

async function shouldSkipProject(projectName: string, options: ReleaseExecutorSchema): Promise<boolean> {
  // Check per-project configuration
  if (options.releaseConfig?.[projectName]?.skip) {
    return true;
  }

  // Check include/exclude patterns
  if (options.includeProjects?.length) {
    const isIncluded = options.includeProjects.some(pattern =>
      projectName.match(new RegExp(pattern.replace('*', '.*')))
    );
    if (!isIncluded) return true;
  }

  if (options.excludeProjects?.length) {
    const isExcluded = options.excludeProjects.some(pattern =>
      projectName.match(new RegExp(pattern.replace('*', '.*')))
    );
    if (isExcluded) return true;
  }

  // Check project filter
  if (options.projectFilter) {
    const matches = projectName.match(new RegExp(options.projectFilter.replace('*', '.*')));
    if (!matches) return true;
  }

  return false;
}

async function readVersionFromFile(
  context: ExecutorContext,
  projectRoot: string,
  options: ReleaseExecutorSchema
): Promise<{ version: string; filePath: string }> {
  const versionFile = options.versionFile || 'project.json';
  const versionPath = options.versionPath || 'version';
  const filePath = path.join(context.root, projectRoot, versionFile);

  if (!fs.existsSync(filePath)) {
    throw new Error(`Version file not found: ${filePath}`);
  }

  try {
    if (versionFile.endsWith('.json')) {
      const content = JSON.parse(fs.readFileSync(filePath, 'utf8'));
      const version = getNestedProperty(content, versionPath);
      return { version: version || '0.0.0', filePath };
    } else {
      // For non-JSON files like version.txt, read the entire content as version
      const version = fs.readFileSync(filePath, 'utf8').trim();
      return { version: version || '0.0.0', filePath };
    }
  } catch (error: any) {
    throw new Error(`Could not read version from ${filePath}: ${error.message}`);
  }
}

async function writeVersionToFile(
  context: ExecutorContext,
  projectRoot: string,
  options: ReleaseExecutorSchema,
  newVersion: string,
  filePath: string
): Promise<void> {
  const versionFile = options.versionFile || 'project.json';
  const versionPath = options.versionPath || 'version';

  try {
    if (versionFile.endsWith('.json')) {
      const content = JSON.parse(fs.readFileSync(filePath, 'utf8'));
      setNestedProperty(content, versionPath, newVersion);
      fs.writeFileSync(filePath, JSON.stringify(content, null, 2));
    } else {
      // For non-JSON files, write the version directly
      fs.writeFileSync(filePath, newVersion);
    }
    logger.info(`Updated ${filePath} with version ${newVersion}`);
  } catch (error: any) {
    throw new Error(`Could not write version to ${filePath}: ${error.message}`);
  }
}

function getNestedProperty(obj: any, path: string): string {
  return path.split('.').reduce((current, key) => current?.[key], obj);
}

function setNestedProperty(obj: any, path: string, value: string): void {
  const keys = path.split('.');
  const lastKey = keys.pop()!;
  const target = keys.reduce((current, key) => {
    if (!current[key]) current[key] = {};
    return current[key];
  }, obj);
  target[lastKey] = value;
}

function generateTagName(
  projectName: string,
  version: string,
  options: ReleaseExecutorSchema
): string {
  const tagNaming = options.tagNaming || {};

  const prefix = tagNaming.prefix || (tagNaming.includeProjectName !== false ? `${projectName}-v` : 'v');
  const suffix = tagNaming.suffix || '';
  const format = tagNaming.format || '{prefix}{version}{suffix}';

  return format
    .replace('{prefix}', prefix)
    .replace('{version}', version)
    .replace('{suffix}', suffix)
    .replace('{projectName}', projectName);
}

export default runExecutor;